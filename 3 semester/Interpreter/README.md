# Интерпретатор Rs (DV - Double Version)

### Краткая инструкция:
* объявление переменных происходит с помощью ключевого слова **"let"**:
  ```
   let var1 = 5, var2
   # var1 = 5, var2 = NAN
   # стоит отметить, что операции с NAN запрещены
  ```
* команды языка (создавать переменные и функции с именами команда запрещено):
  * следующие команды были заимствованы из Python:
    * **print**
    * **input**
    * **if**, **elif**, **else**
    	* блок кода у данных команд должен быть окружен фигурными скобками **{}**
	* круглые скобки в условии можно опускать
    * **while**
    	* блок кода у while должен быть окружен фигурными скобками **{}**
	* круглые скобки в условии можно опускать
    * логические операции: **and**, **or**, **not**
  * математические:
    * **sin**, **cos**
    * **exp**
    * **log**:
      * существует 2 варианта данной функции:
      ```
      # log(n) == натуральный логарифм от n
      # log(n, base) == логарифм от n по основанию base
      ```
  * остальные:
    * **let** - объявление переменных
    * **fun** - создание функций
    	* блок кода у функции должен быть окружен фигурными скобками **{}**
    * **return**
* создание функций осуществляется с помощью ключевого слова **"fun"**:
  ```
  # общий синтаксис создания следующий:
  # fun my_function ([let param1, param2, ...]) {
  #   ... function body ...
  #   [return]
  # }
  # то, что заключено в квадратных скобках [...] является необязательным 
  
  fun foo(let a, b) {
    print("a:", a) # a: a
    print("b:", b) # b: b
  }
  ```
  * функции можно объявлять и вызывать внутри других функции (даже если вызывающая функция имеет имя родителя):
  ```
  fun foo() {
    print("foo parent")
    fun foo() {
      print("foo child")
    }
    foo()
  }
  foo() 
  # "foo parent"
  # "foo child"
  ```
  * отсюда следует, что функции можно перегружать:
  ```
  fun foo() {
	  print("first foo")
  }

  fun foo() {
	  print("second foo")
  }

  foo() # "second foo"
  ```
  * в теле функции нельзя создавать уже существующие переменные (это правило не касается аргументов функции):
  ```
  fun foo() {
    let a = 5 # error
    ...
  }
  
  let a = 5
  foo()
  
  # НО!
  
  fun boo(let a) {
    ...
  }
  boo(a) # так можно
  ```
